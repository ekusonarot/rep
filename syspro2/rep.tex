\documentclass[11pt]{jarticle}

\usepackage[dvipdfmx]{graphicx}
\usepackage{listings}

\lstset{
    basicstyle={\ttfamily\small}, %書体の指定
    %frame=tRBl, %フレームの指定
    %framesep=10pt, %フレームと中身（コード）の間隔
    breaklines=true, %行が長くなった場合の改行
    linewidth=16cm, %フレームの横幅
    lineskip=-0.5ex, %行間の調整
    tabsize=2 %Tabを何文字幅にするかの指定
}
\renewcommand{\lstlistingname}{リスト}
\setlength{\oddsidemargin}{-6.35mm}
\setlength{\textwidth}{160.0mm}

\begin{document}

\title{システムプログラミング2\\期末レポート}
\author{09430565\\大橋虎ノ介}
\date{出題日 2020年 10月 ?日\\
提出日\number\year 年\number\month 月\number\day 日\\
締切日 2020年 11月 16日}

\maketitle
\begin{center}
教科書\\
 パターソン\&ヘネシー「コンピュータの構成と設計」第5版(上)(下)
\end{center}
\newpage

\section{概要} \label{sec:abstract}

本実験では，アセンブラ言語でプログラミングを行い，C言語におけるヒープ，
スタックとコンピュータアーキテクチャとの関係， main関数以前の動作などについて，実例を通して理解を深める．
本報告書では，設定された以下5つの課題を解き，最終的にprintf関数のサブセットを実装した結果とそれに対する考察を述べる．

\begin{itemize}
  \item 課題2-1 教科書A.6節 「手続き呼出し規約」に従って，各種手続きをアセンブラで記述せよ．また，記述した syscalls.s の関数をC言語から呼び出すことで， \ref{sec:program}節リスト\ref{hanoi}ハノイの塔を完成させよ．
  \item 課題2-2 spim-gcc の引数保存に関するスタックの利用方法について，説明せよ． そのことは，規約上許されるスタックフレームの最小値24とどう関係しているか． このスタックフレームの最小値規約を守らないとどのような問題が生じるかについて解説せよ．
  \item 課題2-3 リスト\ref{report2-1}をコンパイルした結果をもとに，auto変数とstatic変数の違い，ポインタと配列の違いについてレポートせよ．
  \item 課題2-4 printf など，一部の関数は，任意の数の引数を取ることができる． これらの関数を可変引数関数と呼ぶ． MIPSのCコンパイラにおいて可変引数関数の実現方法について考察し，解説せよ．
  \item 課題2-5 printf のサブセットを実装し， SPIM上でその動作を確認する応用プログラム(自由なデモプログラム)を作成せよ．
\end{itemize}

\section{プログラムの設計方針}

\section{プログラムリストおよび，その説明}

\section{プログラムの使用方法}

\section{プログラム作成過程に関する考察}

\section{設問に対する回答}

本節では概要で設定した課題に対する解答を述べる．

\subsection{課題2-1 各種手続きをアセンブラで記述せよ}

文字列や整数の入出力をアセンブラで記述した（リスト\ref{syscalls}）．

hanoi.sと作成したsyscalls.sをSPIM上にロードし実行した結果を\ref{hanoi_exec}に示す．

\begin{lstlisting}[caption=実行結果,label=hanoi_exec]
Enter number of disks> 3
Move disk 1 from peg 1 to peg 2.
Move disk 2 from peg 1 to peg 3.
Move disk 1 from peg 2 to peg 3.
Move disk 3 from peg 1 to peg 2.
Move disk 1 from peg 3 to peg 1.
Move disk 2 from peg 3 to peg 2.
Move disk 1 from peg 1 to peg 2.
\end{lstlisting}

\subsection{課題2-2 spim-gcc の引数保存に関するスタックの利用方法について，説明せよ}

spim-gccでは，関数を呼び出す際に第1引数～第4引数を保存するためのスタック領域を余分に確保して関数を呼び出す．
この領域は被呼び出し関数が\$a0～\$a3を保存できるようになっている．

スタックフレームの最小値規約24バイトとは\$fp,\$raそして引数4つ，それぞれ4バイトであるから24バイトを保存するための最小値である．

もしこの規約を守らない関数を呼び出した時は，\$a0～\$a3の保存を自分が確保した領域しか使わないため問題にならない．
しかし，規約を守らない関数が規約を守る関数を呼び出した際は，被呼び出し関数によって自分のために確保した領域を破壊してしまう．

呼び出し側で被呼び出し関数のスタック領域を確保する方法には2つのメリットがある．

1つは被呼び出し関数が\$a0～\$a3をスタックへ保存するか決められる点である．
\$a0～\$a3の書き換えが起こらなければメモリへの書き込みを避け高速化できる．

2つ目は，被呼び出し関数から見て，引数が連続した領域に並ぶ点である．そのため，コンパイラの実装が容易になる．

\subsection{課題2-3 auto変数とstatic変数の違い，ポインタと配列の違いについて}

リスト\ref{report2-1}をコンパイルした結果をリスト\ref{report2-1c}に示す．

リスト\ref{report2-1}の1行目：primes\_statはstatic変数であり，16行目：primes\_autoはauto変数である．
リスト\ref{report2-1c}においてprimes\_statと対応する部分を探すと91行目：.comm \_primes\_stat ,40という行が見つかる．
これはデータセグメントに40バイト確保している．
一方，primes\_autoをリスト\ref{report2-1c}から探すと66行目：.ascii "primes\_auto[0]$\backslash$000"という文字列が見つかる．
\$LC4は82行目に使われており，84行目の\_print\_varの第2引数がprime\_auto[0]の値であると分かる．
83行目の\$a1つまり16(\$fp)はスタック領域であるから，auto変数はスタック領域に保存されていることが分かる．

データセグメントにあるstatic変数はプログラムの開始から終了まで値を保持し続けるが，スタック領域にあるauto変数は
関数が終了するとその領域を解放する．

リスト\ref{report2-1}の3行目：string\_ptrはポインタであり，4行目：string\_aryは配列である．
リスト\ref{report2-1c}においてstring\_ptrと対応する部分は23行目にある．
ここをみると，string\_ptrは18行目"ABCDEFG$\backslash$000"というデータを持った\$LC0へのアドレスを持っていることが分かる．
一方，リスト\ref{report2-1c}において，string\_aryに対応する部分は26行目にある．
ここでは配列が"ABCDEFG$\backslash$000"というでーたを持っていることが分かる．

\subsection{課題2-4 MIPSのCコンパイラにおいて可変引数関数の実現方法について}

C言語では，可変長の引数を扱うために， … を使った構文が用意されている．
spim-gccでは，関数の引数が呼び出した関数のスタック領域に順番に並べられる．

実装するmyprintf関数の第1引数は必須であるので，そのアドレスを元に第2引数，
第3引数を求めることができる．
spim-gccのスタック利用規約から，第2引数は第1引数の4バイト先にあり，
第3引数はさらに4バイト先にあるので，引数のアドレスは以下の式により求められる．
\\
第n引数のアドレス=第n-1引数のアドレス+((sizeof(第n-1引数)+3) /4) *4;
\\
((sizeof(第n-1引数)+3) /4) *4となるのは，spim-gccでのsizeofは3以下の時4の倍数に切り上げるからである．

引数の数と型については，第一引数の\%とsやdなどの識別子をみれば良い．

\subsection{課題2-5 printf のサブセットを実装し， SPIM上でその動作を確認する応用プログラム(自由なデモプログラム)を作成せよ．}

\section{プログラムリスト} \label{sec:program}

\begin{lstlisting}[caption=hanoi.c,label=hanoi,numbers=left]
  void hanoi(int n, int start, int finish, int extra)
  {
    if (n != 0){
      hanoi(n - 1, start, extra, finish);
      print_string("Move disk ");
      print_int(n);
      print_string(" from peg ");
      print_int(start);
      print_string(" to peg ");
      print_int(finish);
      print_string(".\n");
      hanoi(n - 1, extra, finish, start);
    }
  }
  
  main()
  {
    int n;
    print_string("Enter number of disks> ");
    n = read_int();
    hanoi(n, 1, 2, 3);
  }
\end{lstlisting}


\begin{lstlisting}[caption=report2-1.c,label=report2-1,numbers=left]
int primes_stat[10];

char * string_ptr   = "ABCDEFG";
char   string_ary[] = "ABCDEFG";

void print_var(char *name, int val)
{
  print_string(name);
  print_string(" = ");
  print_int(val);
  print_string("\n");
}

main()
{
  int primes_auto[10];

  primes_stat[0] = 2;
  primes_auto[0] = 3;

  print_var("primes_stat[0]", primes_stat[0]);
  print_var("primes_auto[0]", primes_auto[0]);
}
\end{lstlisting}

\begin{lstlisting}[caption=report2-1.s,label=report2-1c,numbers=left]
	.file	1 "step4-1.c"

 # -G value = 0, Cpu = r2000, ISA = 1
 # GNU C version 2.96-mips3264-000710 (mipsel-linux) compiled by GNU C version 2.96 20000731 (Red Hat Linux 7.2 2.96-112.7.2).
 # [AL 1.1, MM 40] BSD Mips
 # options passed:  -mno-abicalls -mrnames -mmips-as -mcpu=r2000 -O0
 # -fleading-underscore -finhibit-size-directive -fverbose-asm
 # options enabled:  -fpeephole -fkeep-static-consts -fpcc-struct-return
 # -fsched-interblock -fsched-spec -fnew-exceptions -fcommon
 # -finhibit-size-directive -fverbose-asm -fgnu-linker -flive-range-gdb
 # -fargument-alias -fleading-underscore -fdelay-postincrement -fident
 # -fmath-errno -msplit-addresses -mrnames -mdebugf -mdebugi -mcpu=r2000


	.rdata
	.align	0
	.align	2
$LC0:
	.ascii	"ABCDEFG\000"
	.data
	.align	0
	.align	2
_string_ptr:
	.word	$LC0
	.align	2
_string_ary:
	.ascii	"ABCDEFG\000"
	.rdata
	.align	0
	.align	2
$LC1:
	.ascii	" = \000"
	.align	2
$LC2:
	.ascii	"\n\000"
	.text
	.align	2
	.set	nomips16
_print_var:
	subu	$sp,$sp,24
	sw	$ra,20($sp)
	sw	$fp,16($sp)
	move	$fp,$sp
	sw	$a0,24($fp)
	sw	$a1,28($fp)
	lw	$a0,24($fp)
	jal	_print_string
	la	$a0,$LC1
	jal	_print_string
	lw	$a0,28($fp)
	jal	_print_int
	la	$a0,$LC2
	jal	_print_string
	move	$sp,$fp
	lw	$ra,20($sp)
	lw	$fp,16($sp)
	addu	$sp,$sp,24
	j	$ra
	.rdata
	.align	0
	.align	2
$LC3:
	.ascii	"primes_stat[0]\000"
	.align	2
$LC4:
	.ascii	"primes_auto[0]\000"
	.text
	.align	2
	.set	nomips16
main:
	subu	$sp,$sp,64
	sw	$ra,60($sp)
	sw	$fp,56($sp)
	move	$fp,$sp
	li	$v0,2			# 0x2
	sw	$v0,_primes_stat
	li	$v0,3			# 0x3
	sw	$v0,16($fp)
	la	$a0,$LC3
	lw	$a1,_primes_stat
	jal	_print_var
	la	$a0,$LC4
	lw	$a1,16($fp)
	jal	_print_var
	move	$sp,$fp
	lw	$ra,60($sp)
	lw	$fp,56($sp)
	addu	$sp,$sp,64
	j	$ra

	.comm	_primes_stat,40
\end{lstlisting}

\begin{lstlisting}[caption=syacalls.s,label=syscalls,numbers=left]
  .text
  .align  2
_print_int:
  subu    $sp, $sp, 24
  sw      $ra, 20($sp)
  sw      $fp, 16($sp)

  li      $v0, 1
  syscall

  lw      $fp, 16($sp)
  lw      $ra, 20($sp)
  addi    $sp, $sp, 24

  j       $ra

  .align  2
_print_string:
  subu    $sp, $sp, 24
  sw      $ra, 20($sp)
  sw      $fp, 16($sp)

  li      $v0, 4
  syscall

  lw      $fp, 16($sp)
  lw      $ra, 20($sp)
  addi    $sp, $sp, 24

  j       $ra


  .align  2
_read_int:
  subu    $sp, $sp, 24
  sw      $ra, 20($sp)
  sw      $fp, 16($sp)

  li      $v0, 5
  syscall

  lw      $fp, 16($sp)
  lw      $ra, 20($sp)
  addi    $sp, $sp, 24

  j       $ra

  

  .align  2
_read_string:
  subu    $sp, $sp, 24
  sw      $ra, 20($sp)
  sw      $fp, 16($sp)

  li      $v0, 8
  syscall

  lw      $fp, 16($sp)
  lw      $ra, 20($sp)
  addi    $sp, $sp, 24

  j       $ra
\end{lstlisting}

\end{document}
