\documentclass[11pt]{jarticle}

\usepackage[dvipdfmx]{graphicx}
\usepackage{listings,jlisting}

\lstset{
    basicstyle={\ttfamily\small}, %書体の指定
    %frame=tRBl, %フレームの指定
    %framesep=10pt, %フレームと中身（コード）の間隔
    breaklines=true, %行が長くなった場合の改行
    linewidth=16cm, %フレームの横幅
    lineskip=-0.5ex, %行間の調整
    tabsize=2 %Tabを何文字幅にするかの指定
}
\renewcommand{\lstlistingname}{リスト}
\setlength{\oddsidemargin}{-6.35mm}
\setlength{\textwidth}{160.0mm}

\begin{document}

\title{情報工学実験C（ソフトウェア）\\コンパイラ}
\author{09430565\\大橋虎ノ介}
\date{提出日 2021年 1月 11日\\
締切日 2021年  2月 2日}

\maketitle
\newpage

\section{概要}\label{sec:abstract}

本実験では，YACC，LEXというプログラムジェネレータを使って
手続き型言語のコンパイラを作成する．
コンパイラを作成することでプログラミング言語で書かれたプログラムと
アセンブリ言語との対応について深く理解する．

コンパイルによって生成したアセンブラコードの動作確認は，mipsアセンブラ・プロセッサシミュレータである
mapsを用いて行う．

最終的に，作成したコンパイラでアセンブラコードを生成し，
以下5つの問題を解くことができた．

\begin{enumerate}
    \item 1から10までの数の和
    \item 5の階乗
    \item FizzBuzz問題
    \item エラトステネスのふるいを用いて1から1000までの素数を調べる
    \item 2つの2$\times$2行列の積の計算
\end{enumerate}

\section{プログラムの作成方針}\label{sec:policy}

\subsection{言語仕様} \label{sec:specific}

コンパイラが受理する言語仕様をリスト\ref{list:specific}に示す．

\begin{lstlisting}[label=list:specific, caption=言語仕様]
<プログラム>::= <変数宣言部> <文集合> 
<変数宣言部>::= <宣言文> <変数宣言部> 
|   <宣言文> 
<宣言文>::= define <識別子> ; 
|   array <識別子> [ 数 ] ; 
<文集合>::= <文> <文集合> | <文> 
<文>::= <代入文> | <ループ文> | <条件分岐文> 
<代入文>::= <変数> = <算術式> ; 
<算術式>::= <算術式> <加減演算子> <項> | <項> 
<項>::= <項> <乗除演算子> <因子> | <因子> 
<因子>::= <変数> | 数 | ( <算術式> ) 
<加減演算子>::= + | - 
<乗除演算子>::= * | / | %
<変数>::= <識別子> 
|   <識別子> [ <算術式> ]
<ループ文>::= while ( <条件式> ) { <文集合> } 
<条件分岐文>::= if ( <条件式> ) { <文集合> } 
|   if ( <条件式> ) { <文集合> } else { <文集合> }
|   if ( <条件式> ) { <文集合> } else <条件分岐文>
<条件式>::= <算術式> <比較演算子> <算術式>
<比較演算子>::= == | < | >
<識別子>::= <英字> <英数字列> | <英字>
<英数字列>::= <英数字> <英数字列> | <英数字>
<英数字>::= <英字> | <数字>
<数>::= <数字> <数> | <数字>
<英字>::= a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z|A|B|
C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z
<数字>::= 0|1|2|3|4|5|6|7|8|9
\end{lstlisting}

\subsection{受理されるプログラム例}

\ref{sec:specific}章で述べた言語仕様では，リスト\ref{program:example}のようなプログラムが受理される．

\begin{lstlisting}[caption=受理されるプログラムの例, label=program:example, numbers=left]
    define i;
    define sum;
    array a[10];

    i=0;
    sum=0;
    while(i<10){
        sum=sum+i;
        a[i]=sum;
        i=i+1;
    }
\end{lstlisting}

\subsection{メモリの使い方}

コンパイルしたアセンブラコードでは，メモリ空間をテキスト領域，データ領域，スタック領域の3つに分けて使用する．

テキスト領域は0x00000024番地から始まる．命令を格納する領域である．

データ領域は0x10004000番地から始まる．コンパイルするプログラム内で宣言された
変数の値を保存する領域である．

スタック領域は0x7ffffffcからアドレスの小さい方向に使用していく．算術式を展開する際に
式の値を保存するために使用する．

\subsection{レジスタの使い方}

ここでは，コンパイラによって生成するアセンブラコードでの
レジスタの使い方についてまとめる．

\begin{table}[h] \label{table:register} \caption{レジスタの使い方}
    \begin{center}
        \begin{tabular}{l|l}
            レジスタ & 使い方 \\ \hline
            \$sp & スタックポインタ，スタック領域の操作位置を保存 \\
            \$t0 & データ領域の先頭番地を保存 \\
            \$t1 & 算術式において計算結果を一時的な退避 \\
            \$t2 & 条件式の結果を保存 \\
            \$t3 & 変数のオフセットを保存 \\
            \$t4 & 代入文における計算結果の一時的な退避 \\
            \$t5 & 即値データを保存 \\
            \$s0 & 条件式において計算結果の一時的な退避 \\
            \$v0 & 計算結果を保存
        \end{tabular}
    \end{center}
\end{table}

\subsection{算術式のコード生成}

算術式のコード生成には，スタックを用いる方法を採用した．
この方法は，抽象構文木をたどりながらコード生成を行う．
スタックは，中間の計算結果を保存するために使用する．

以下に算術式のコード生成の手順を示す．

\begin{enumerate}
    \item 左の子のコード生成を行う
    \item 1.の結果が入っている\$v0レジスタの値をスタックにPUSHする．
    \item 右の子のコード生成を行う．
    \item \$v0レジスタの内容を\$t1レジスタに移動．
    \item スタックから値をPOPして\$v0に入れる
    \item このノードに対応した演算 \$v0, \$v0, \$t1
\end{enumerate}

スタックはスタックポインタ\$spで実現する．
以下にPUSH，POPの手順を示す．\\

\textbf{PUSH}

\begin{enumerate}
    \item \$spを4減らす．
    \item \$spのアドレスに\$v0の内容を保存する．
\end{enumerate}

\textbf{POP}

\begin{enumerate}
    \item \$spの内容を\$v0にロードする．
    \item \$spに4加える．
\end{enumerate}

\section{工夫した点}

本節では，基本言語仕様から独自に拡張した点を紹介する．

\subsection{配列の添え字に変数を含む算術式が使用可能}

基本言語仕様では，配列の添え字に定数のみ対応していたが，変数を含む算術式を
使用できるように拡張した．

これにより，ループ文などで配列の要素を更新することができる．
また，２次元配列を実装せずとも，添え字に２つの変数を用いることで疑似的に２次元配列を実現可能である．

\subsection{剰余演算子}

基本言語仕様では四則演算のみ対応していたが，それに加えて剰余演算子を使用できるように拡張した．
これにより，FizzBuzz問題を簡単に書けるようになった

\section{最終課題を解くプログラム}

\subsection{1から10までの数の和}

\begin{lstlisting}
    define i;
    define sum;

    i=0;
    sum=0;
    while(i<10){
        i=i+1;
        sum=sum+i;
    }
\end{lstlisting}

\subsection{5の階乗}

\begin{lstlisting}
    define i;
    define factorial;

    i=0;
    factorial=0;
    while(i<5){
        i=i+1;
        factorial=factorial*i;
    }
\end{lstlisting}

\subsection{FizzBuzz問題}

\begin{lstlisting}
    define i;
    array FizzBuzz[100];

    i=0;
    while(i<100){
        FizzBuzz[i]=i;

        if(i%5==0){
            FizzBuzz[i]=187;
        }else if(i%3==0){
            FizzBuzz[i]=255;
        }
        if(i%5==0){
            if(i%3==0){
                FizzBuzz[i]=251;
            }
        }
        i=i+1;
    }
\end{lstlisting}

\subsection{エラトステネスのふるいを用いて1から1000までの素数を調べる}

\begin{lstlisting}
    define dummy;
    define i;
    define j;
    array list[1000];
    array prime[500];
    
    i=0;
    while(i<999){
        list[i]=i+2;
        i=i+1;
    }

    i=0;
    while(i<10){
        j=0;
        while(j<999){
            if(list[j]==0){
                dummy=0;
            } else {
                prime[i]=list[j];
                while(j<999){
                    if(list[j]%prime[i]==0){
                        list[j]=0;
                    }
                    j=j+1;
                }
            }
            j=j+1;
        }
        i=i+1;
    }
\end{lstlisting}

\subsection{2つの2$\times$2行列の積の計算}

\end{document}
